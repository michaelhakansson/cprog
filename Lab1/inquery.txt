0.1  MAKE IT HAPPEN  
--------------------------------------------------------------------------------
:::: What does `$*` mean inside a makefile?
--------------------------------------------------------------------------------

Answer: $* is a variable that takes the name from %, which in turn corresponds to the file name (excl. file ending) that is passed along as an argument to make.

--------------------------------------------------------------------------------
:::: What is the purpose of `-Wall` and -g, when passed as arguments to g++?
--------------------------------------------------------------------------------

Answer:
 	-Wall aktiverar en uppsättning vanliga varningar, och som är enkla att undvika.
	-g producerar debugging information

--------------------------------------------------------------------------------
:::: What is the difference between an object file, and an executable?
--------------------------------------------------------------------------------

Answer: En executable är EN fil, typiskt innehållande maskinkod, som kan exekveras.
Object filer innehåller också maskinkod, men är uppdelade i flera filer som generellt
sett inte är exekverbara. Med hjälp av en länkare (linker) sätts dessa object filer
ihop till en executable.

--------------------------------------------------------------------------------





0.2  HELLO WORLD
-------------------------------------------------------------------------------
:::: What is the purpose of `std::cout`, `std::cerr`, and `std::clog`,
     respectively?
-------------------------------------------------------------------------------

Answer:

std::cout används för "vanliga" utskrifter, standard output stream.

std::cerr används för felutskrifter.

std:clog används för att göra loggutskrifter.


-------------------------------------------------------------------------------




0.3  TRAIN SPOTTING

    int powerof (int x, int y) {
      int res = 1;

      for (int i = 0; i < y; ++i);
        res *= x;

      return res;
    }

    int main () {
      int const a = 2;
      int const b = 4;

      int   x = powerof(a, b); 
      float y = 3.1415;

      std::cout << a << "^" << b << " = " << x << ";\n";

      if (y == 3.1415)
        std::cout << y << " is equal to 3.1415!\n";
      else
        std::cout << y << " is not equal to 3.1415!\n";
    }

--------------------------------------------------------------------------------
:::: Why does not `powerof` return the expected value (16), when invoked with 2 and 4?
--------------------------------------------------------------------------------

Answer: res *= x; is not a part of the for loop due to the ";" in the end of the
for line. Thus, res is just set to res*x and then returned.

--------------------------------------------------------------------------------
:::: Why does not `y` compare equal to 3.1415?
--------------------------------------------------------------------------------

Answer: Because y is a float and 3.1415 is a double.

--------------------------------------------------------------------------------
:::: Is there any difference in behavior if we compare `y` to 3.1415f, if so: why?
--------------------------------------------------------------------------------

Answer: Yes, if we compare with 3.1415f, we are comparing numbers of the same type,
and happen to get a different behavior (it answers with that it IS equal).

--------------------------------------------------------------------------------
:::: What is the recommended method to use when trying to determine if
:::: two floating-point values are equal, and why?
--------------------------------------------------------------------------------

Answer: Use a small number (epsilon) that you choose as the error margin, and check if it is greater than the absolute difference of the two compared values. This must be used since floating-point values are to imprecise to be able to be compared with certainty.
--------------------------------------------------------------------------------


0.4 DOES IT FIT

int count_if_followed_by (char const * p, int len, char a, char b) {
  int        count = 0;
  char const * end = p + len;

  while (p != end) {
    if (*p == a && *(p+1) == b)
      count += 1;

    ++p;
  }

--------------------------------------------------------------------------------
:::: Why is it important to test the boundary conditions of an implementation,
     especially in the case of `count_if_followed_by`?
--------------------------------------------------------------------------------

Answer: Firstly, it is easy to make errors with boundary conditions. In this specific case, the documentation also states the range [data, data+len) specifically. It is then very dangerous to not test it, since other people can use this code and trust the documentation.

--------------------------------------------------------------------------------



0.5 WILL IT FLOAT (birth.cpp)

class A {
public:
   A () {
     std::cout << "default-constructor" << std::endl;
   }

   A (A const& src) {
     std::cout << "copy-constructor" << std::endl;
   }

  ~A () {
    std::cout << "destructor" << std::endl;
  }

   A(char const* s) {
      std::cout << "some other constructor" << std::endl;
   }

   A& operator= (A const& src) {
     std::cout << "the assignment operator" << std::endl;
     return *this;
   }
};

void no_ref(A a) {}
void with_ref(const A & a) {}

int main()
{
    A a("my name is a");

    A b = a;          // what is the difference
    A c(a);           // between these three
    A d;              // forms of initialization?

    d = a;

      no_ref (a);     // will this copy the value of `a`? Yes
    with_ref (a);     // will this copy the value of `a`? No, just reference to a.

    A *aa = new A[5];
    delete aa;        // what will happen?
    return 0;
}

--------------------------------------------------------------------------------
:::: What different constructors are invoked, and when?
--------------------------------------------------------------------------------


Answer: 
A(char const* s) (aka the "some other constructor") is invoked when
  A a("my name is a") is executed


A (A const& src) (aka the "copy constructor") is invoked when
  A b = a; is executed since a is defined usnig =. 
  A c(a); is executed since we pass an object as an argument to a parameter of nonref type
  no_ref (a); is executed since the value of 'a' is copied when A is initialized.
              no_ref is pass by value

A& operator= (A const& src) (aka the "the assignment operator") is invoked when
  d = a; is executed since the already initialized object b is assigned a.

A () (aka the "default-constructor") is invoked when
  A *aa = new A[5]; is executed. It is invoked for every element in the array (5 times).


--------------------------------------------------------------------------------
:::: Will there be any temporaries created, if so; when?
--------------------------------------------------------------------------------

Answer: When we call the no_ref function, we initianlize the object with pass by 
value, and the initialized variable will be destructed when the function ends, because
it is on the stack.

--------------------------------------------------------------------------------
:::: When are the objects destructed, an why?
--------------------------------------------------------------------------------

Answer: Objects are destructed when they go out of scope, or when the destructor is
manually invoked.

--------------------------------------------------------------------------------
:::: What will happen if we try to free the dynamically allocated
:::: memory through `delete p`, instead of `delete [] p`?

Answer: We get a segmentation fault, since the behavior of invoking a "non-array-destructor"
on an array is undefined.

--------------------------------------------------------------------------------


0.5 WILL IT FLOAT (bad_plumming.cpp)

struct Data {
    int x, y, z;
};  

Data ** foo(Data ** v, int x) {
    for (int i = 0; i < x; i++)
        if (v[i] != 0)
            v[i] = new Data;
    return v;
}

int main () {
    const int size = 5;
    Data ** v = new Data * [size];
    foo(v, size);
}

--------------------------------------------------------------------------------
:::: valgrind indicates that the program suffers from a few problems, which and
:::: why?
--------------------------------------------------------------------------------

Answer: valgrind tells us that v[i] is unitialized, since no Data constructor
which initializes the array is present. The if (v[i] != 0) will read undefined
data.

valgrind also states that there is a memory leak. That is due to that memory is
allocated (with new) but never freed.

--------------------------------------------------------------------------------
:::: If you comment out the entire if-block in foo, is there any difference in
:::: how much memory that is leaked?
--------------------------------------------------------------------------------

Answer: No, for us, there was no difference. That is because we happened to allocate
memory for v in an area that contained 0's. If we would have allocated memory for v
in a memory space that was not 0, the result would have been different.

--------------------------------------------------------------------------------
:::: Revert bad_plumming.cpp to its original state, and comment out
:::: only the line that contains the if-condition.
::::
:::: If you now change the last line of `main` to the following; why is it
:::: that valgrind still issue diagnostics related to memory management?
::::
:::: Data ** p = foo (v, size);
:::: delete [] p;
--------------------------------------------------------------------------------

Answer: Now, the memory that p (and v) points to is freed, but not the allocated
memory for the elements in the vector is not freed. Hence, memory is leaking.


--------------------------------------------------------------------------------



0.6  THE SIMPLE CONTAINER
--------------------------------------------------------------------------------
:::: `operator[]` must in some cases be marked as `const`, but not always; when,
:::: and why?
--------------------------------------------------------------------------------

Answer: When the operator [] is used on a non-const object, the operator not marked
const will be used. In that case, modifying of the object is allowed. But when the
operator [] is used on a const object, the 'operator[]' marked 'const' will be used.
In this case, no modification is allowed.

--------------------------------------------------------------------------------
:::: The semantics of copying a UIntVector might not be trivial; why must we 
:::: manually implement the relevant code, instead of having the compiler generate
:::: it for us?
--------------------------------------------------------------------------------

Answer: ...

--------------------------------------------------------------------------------



0.7  THE TEMPLATE VECTOR
--------------------------------------------------------------------------------
:::: Iterating over a range of elements can be done with a range-based for-loop,
:::: but the type of `source` must meet certain requirements; what are they?
--------------------------------------------------------------------------------

Answer: ...

--------------------------------------------------------------------------------
:::: The C++ Standard sometimes state that a type in the Standard Library is
:::: "unspecified"; why do you think that is?
--------------------------------------------------------------------------------

Answer: ...

--------------------------------------------------------------------------------




